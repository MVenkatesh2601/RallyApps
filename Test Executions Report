<!DOCTYPE html>
<html>
<head>
    <title>Test Execution Dashboard</title>
    <script src="https://rally1.rallydev.com/apps/2.1/sdk.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 10px;
        }
        .controls {
            margin-bottom: 10px;
        }
        select, button {
            margin-right: 10px;
            padding: 5px 10px;
        }
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 10px;
        }
        th, td {
            text-align: center;
            padding: 10px;
            border: 1px solid #ccc;
        }
        th {
            background-color: #f4f4f4;
        }
        .progress-bar {
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }
        .progress-fill {
            height: 100%;
            background-color: #4caf50;
            text-align: center;
            color: white;
            line-height: 20px;
        }
        .refresh-button {
            background-color: #4caf50;
            color: white;
            border: none;
            cursor: pointer;
            padding: 8px 16px;
            border-radius: 5px;
        }
        .refresh-button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>

<div class="controls">
    <select id="iterationDropdown"></select>
    <select id="typeDropdown">
        <option value="All">All</option>
        <option value="TestSet">Test Sets</option>
        <option value="UserStory">User Stories</option>
    </select>
    <button class="refresh-button" onclick="loadData()">ðŸ”„ Refresh</button>
</div>

<table id="resultsTable">
    <thead>
        <tr>
            <th>S.No</th>
            <th>ID</th>
            <th>Name</th>
            <th>Execution %</th>
            <th>Pass %</th>
            <th>Not Run</th>
            <th>Pass</th>
            <th>Fail</th>
            <th>Blocked</th>
            <th>Error</th>
            <th>Total Test Cases</th>
        </tr>
    </thead>
    <tbody>
    </tbody>
</table>

<script>

    Rally.onReady(function() {
        loadIterations();
        loadData();
    });

    function loadIterations() {
        Ext.create('Rally.data.wsapi.Store', {
            model: 'Iteration',
            fetch: ['Name', 'ObjectID'],
            limit: Infinity
        }).load({
            callback: function(records) {
                var dropdown = document.getElementById('iterationDropdown');
                dropdown.innerHTML = "";
                records.forEach(function(iteration) {
                    var option = document.createElement('option');
                    option.value = iteration.get('ObjectID');
                    option.text = iteration.get('Name');
                    dropdown.appendChild(option);
                });
            }
        });
    }

    function loadData() {
        const iterationId = document.getElementById('iterationDropdown').value;
        const type = document.getElementById('typeDropdown').value;

        Promise.all([
            loadTestSets(iterationId),
            loadUserStories(iterationId)
        ]).then(([testSets, userStories]) => {

            const ids = [];
            if (type === "TestSet" || type === "All") {
                ids.push(...testSets.map(ts => ({ id: ts.get('FormattedID'), name: ts.get('Name'), type: 'TestSet', objectId: ts.get('ObjectID') })));
            }
            if (type === "UserStory" || type === "All") {
                ids.push(...userStories.map(us => ({ id: us.get('FormattedID'), name: us.get('Name'), type: 'UserStory', objectId: us.get('ObjectID') })));
            }

            if (ids.length === 0) {
                renderTable([]);
                return;
            }

            loadTestCases(testSets, userStories).then(testCases => {
                const groupedResults = groupTestCases(ids, testCases);
                renderTable(groupedResults);
            });
        });
    }

    function loadTestSets(iterationId) {
        return new Promise((resolve) => {
            Ext.create('Rally.data.wsapi.Store', {
                model: 'TestSet',
                fetch: ['FormattedID', 'Name', 'ObjectID', 'Iteration'],
                filters: [{ property: 'Iteration.ObjectID', value: iterationId }],
                limit: Infinity
            }).load({
                callback: function(records) {
                    resolve(records);
                }
            });
        });
    }

    function loadUserStories(iterationId) {
        return new Promise((resolve) => {
            Ext.create('Rally.data.wsapi.Store', {
                model: 'HierarchicalRequirement',
                fetch: ['FormattedID', 'Name', 'ObjectID', 'Iteration'],
                filters: [{ property: 'Iteration.ObjectID', value: iterationId }],
                limit: Infinity
            }).load({
                callback: function(records) {
                    resolve(records);
                }
            });
        });
    }

    function loadTestCases(testSets, userStories) {
        const filters = [];

        testSets.forEach(ts => {
            filters.push({ property: 'TestSet.ObjectID', value: ts.get('ObjectID') });
        });

        userStories.forEach(us => {
            filters.push({ property: 'WorkProduct.ObjectID', value: us.get('ObjectID') });
        });

        if (filters.length === 0) {
            return Promise.resolve([]);
        }

        const rallyFilters = Rally.data.wsapi.Filter.or(filters);

        return new Promise((resolve) => {
            Ext.create('Rally.data.wsapi.Store', {
                model: 'TestCase',
                fetch: ['FormattedID', 'Name', 'LastVerdict', 'TestSet', 'WorkProduct'],
                filters: rallyFilters,
                limit: Infinity
            }).load({
                callback: function(records) {
                    resolve(records);
                }
            });
        });
    }

    function groupTestCases(ids, testCases) {
        const results = ids.map(item => {
            return {
                id: item.id,
                name: item.name,
                type: item.type,
                total: 0,
                pass: 0,
                fail: 0,
                error: 0,
                blocked: 0,
                notrun: 0
            };
        });

        results.forEach(group => {
            testCases.forEach(tc => {
                if ((group.type === 'TestSet' && tc.get('TestSet') && tc.get('TestSet').ObjectID === group.objectId) ||
                    (group.type === 'UserStory' && tc.get('WorkProduct') && tc.get('WorkProduct').ObjectID === group.objectId)) {

                    group.total++;
                    switch (tc.get('LastVerdict')) {
                        case "Pass": group.pass++; break;
                        case "Fail": group.fail++; break;
                        case "Error": group.error++; break;
                        case "Blocked": group.blocked++; break;
                        default: group.notrun++; break;
                    }
                }
            });
        });

        return results;
    }

    function renderTable(data) {
        const tbody = document.getElementById('resultsTable').getElementsByTagName('tbody')[0];
        tbody.innerHTML = "";
        let totalTotal = 0, totalPass = 0, totalFail = 0, totalError = 0, totalBlocked = 0, totalNotRun = 0;

        data.forEach((item, index) => {
            const row = tbody.insertRow();
            row.insertCell(0).innerText = index + 1;
            row.insertCell(1).innerText = item.id;
            row.insertCell(2).innerText = item.name;

            const execPercent = item.total > 0 ? ((item.pass + item.fail + item.error + item.blocked) / item.total) * 100 : 0;
            const passPercent = item.total > 0 ? (item.pass / item.total) * 100 : 0;

            row.insertCell(3).innerHTML = getProgressBar(execPercent);
            row.insertCell(4).innerHTML = getProgressBar(passPercent);

            row.insertCell(5).innerText = item.notrun;
            row.insertCell(6).innerText = item.pass;
            row.insertCell(7).innerText = item.fail;
            row.insertCell(8).innerText = item.blocked;
            row.insertCell(9).innerText = item.error;
            row.insertCell(10).innerText = item.total;

            totalTotal += item.total;
            totalPass += item.pass;
            totalFail += item.fail;
            totalError += item.error;
            totalBlocked += item.blocked;
            totalNotRun += item.notrun;
        });

        if (data.length > 0) {
            const row = tbody.insertRow();
            row.insertCell(0).innerText = '';
            row.insertCell(1).innerText = 'Total';
            row.insertCell(2).innerText = '';

            const execPercent = totalTotal > 0 ? ((totalPass + totalFail + totalError + totalBlocked) / totalTotal) * 100 : 0;
            const passPercent = totalTotal > 0 ? (totalPass / totalTotal) * 100 : 0;

            row.insertCell(3).innerHTML = getProgressBar(execPercent);
            row.insertCell(4).innerHTML = getProgressBar(passPercent);

            row.insertCell(5).innerText = totalNotRun;
            row.insertCell(6).innerText = totalPass;
            row.insertCell(7).innerText = totalFail;
            row.insertCell(8).innerText = totalBlocked;
            row.insertCell(9).innerText = totalError;
            row.insertCell(10).innerText = totalTotal;
        }
    }

    function getProgressBar(percent) {
        return `
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${percent}%; background-color: ${percent >= 80 ? '#4caf50' : (percent >= 50 ? '#ff9800' : '#f44336')}">
                    ${percent.toFixed(1)}%
                </div>
            </div>
        `;
    }

</script>

</body>
</html>

